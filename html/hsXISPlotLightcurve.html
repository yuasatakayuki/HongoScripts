<html>
<body>
<pre>
#!/bin/bash

#20090713 Takayuki Yuasa
#20090826 Takayuki Yuasa
#20090827 Takayuki Yuasa

if [ _$6 = _ ];
then
cat &lt;&lt; EOF
<span style="text-decoration:line-through;color:blue;">xis_plot_lightcurves.sh</span><span style="color:red;">hsXISPlotLightcurve</span> 
               (1:Source ALL Lightcurve File; .lc file)
               (2:Background Lightcurve File; .lc file)
               (3:Output PDF file name; .pdf file)
               (4:&quot;true&quot; if &quot;Source ALL&quot; should be displayed; or &quot;false&quot;)
               (5:&quot;true&quot; if &quot;Background&quot; should be displayed; or &quot;false&quot;)
               (6:&quot;true&quot; if &quot;Source ALL - Bgackground&quot; should be displayed; or &quot;false&quot;)
This script creates a PDF file which displays multiple lightcurves of the XIS.
EOF
exit
fi


#parameters
sourcelc=$1
bgdlc=$2
outputpdffile=$3
show_sourcelc=$4
show_bgdlc=$5
show_allsubbgd=$6

#check
if [ ! -f $sourcelc ];
then
echo &quot;Source Lightcurve &#39;$sourcelc&#39; is not found...exit&quot;
exit
fi

if [ ! -f $bgdlc ];
then
echo &quot;Background Lightcurve &#39;$bgdlc&#39; is not found...exit&quot;
exit
fi

#create output directory
outputdir=`dirname $outputpdffile`
if [ ! -d $outputdir ];
then
	mkdir -p $outputdir &amp;&gt; /dev/null
fi

#create qdp files
for file in $sourcelc $bgdlc $nxblc ;
do
<span style="text-decoration:line-through;color:blue;">delete_qdp_files.sh</span><span style="color:red;">hsQDPDeleteQDPFiles</span> $outputdir/`basename $file .lc`
fplot $file TIME RATE[ERROR] rows=&quot;-&quot; device=&quot;/null&quot; &lt;&lt; EOF &amp;&gt; /dev/null
 
we $outputdir/`basename $file .lc`
exit
EOF
done

#join qdp files
sourceqdp=$outputdir/`basename $sourcelc .lc`.qdp
sourcepco=$outputdir/`basename $sourcelc .lc`.pco
bgdqdp=$outputdir/`basename $bgdlc .lc`.qdp
bgdpco=$outputdir/`basename $bgdlc .lc`.pco
tmpqdpprefix=$outputdir/bbb
tmpqdp=${tmpqdpprefix}.qdp
tmppco=${tmpqdpprefix}.pco
outputqdpprefix=$outputdir/`basename $outputpdffile .pdf`
outputqdp=$outputdir/`basename $outputpdffile .pdf`.qdp
outputpco=$outputdir/`basename $outputpdffile .pdf`.pco

echo &quot;SKIP SING&quot; &gt; $tmpqdp
sed -e &quot;s/`basename $sourcepco .pco`/`basename $tmppco .pco`/g&quot; $sourceqdp &gt;&gt; $tmpqdp
cp $sourcepco $tmppco

bgdqdplinenumber=`cat $bgdqdp | wc -l`
echo &quot;NO NO NO&quot; &gt;&gt; $tmpqdp
tail -`calc &quot;$bgdqdplinenumber-3&quot;` $bgdqdp &gt;&gt; $tmpqdp

#calc source_all - bgd
sourceqdplinenumber=`cat $sourceqdp | wc -l`
if [ ! $bgdqdplinenumber -eq $sourceqdplinenumber ];
then
	echo &quot;Source Lightcurve and Background Lightcurve have different row number...exit&quot;
	exit
fi
source_tmp=`<span style="text-decoration:line-through;color:blue;">get_hash_random.pl</span><span style="color:red;">hsHashRandom</span>`
bgd_tmp=`<span style="text-decoration:line-through;color:blue;">get_hash_random.pl</span><span style="color:red;">hsHashRandom</span>`
source_bgd_tmp=`<span style="text-decoration:line-through;color:blue;">get_hash_random.pl</span><span style="color:red;">hsHashRandom</span>`
tail -`calc &quot;$sourceqdplinenumber-3&quot;` $sourceqdp &gt; $source_tmp
tail -`calc &quot;$bgdqdplinenumber-3&quot;` $bgdqdp &gt; $bgd_tmp
<span style="text-decoration:line-through;color:blue;">matrix_connect_column</span><span style="color:red;">hsDSVConnectColumn</span> $source_tmp 0 $source_tmp 1 $source_tmp 2 $bgd_tmp 1 $bgd_tmp 2 &gt; $source_bgd_tmp
echo &quot;NO NO NO&quot; &gt;&gt; $tmpqdp
ruby &lt;&lt; EOF &gt;&gt; $tmpqdp
open(&quot;$source_bgd_tmp&quot;).each { |line|
	array=line.split(&quot; &quot;)
	print &quot;#{array[0]} #{array[1].to_f()-array[3].to_f()} #{Math::sqrt(array[2].to_f()*array[2].to_f()+array[3].to_f()*array[3].to_f())}\n&quot;
}
EOF

#tune tmppco
tstart=`<span style="text-decoration:line-through;color:blue;">getheader.sh</span><span style="color:red;">hsFitsGetHeader</span> $sourcelc 0 TSTART`
binsize=`<span style="text-decoration:line-through;color:blue;">getheader.sh</span><span style="color:red;">hsFitsGetHeader</span> $sourcelc 1 timedel`
phalowcut=`<span style="text-decoration:line-through;color:blue;">getheader.sh</span><span style="color:red;">hsFitsGetHeader</span> $sourcelc 1 phalcut`
phahighcut=`<span style="text-decoration:line-through;color:blue;">getheader.sh</span><span style="color:red;">hsFitsGetHeader</span> $sourcelc 1 phahcut`
energy_lowcut=`<span style="text-decoration:line-through;color:blue;">xis_pi_to_energy.sh</span><span style="color:red;">hsXISPIToEnergy</span> $phalowcut`
energy_lowcut=`ruby -e &quot;puts sprintf(&#39;%.1f&#39;,$energy_lowcut)&quot;`
energy_highcut=`<span style="text-decoration:line-through;color:blue;">xis_pi_to_energy.sh</span><span style="color:red;">hsXISPIToEnergy</span> $phahighcut`
energy_highcut=`ruby -e &quot;puts sprintf(&#39;%.1f&#39;,$energy_highcut)&quot;`

cat &lt;&lt; EOF &gt;&gt; $tmppco
ti off
fo ro
cs 1.3
lwidth 3
lwidth 3 on 1..50
la ot
la t
la g2 &quot;&quot;
la f `<span style="text-decoration:line-through;color:blue;">targetname.sh</span><span style="color:red;">hsFitsGetTargetName</span> $sourcelc` / `basename $sourcelc` / $binsize s bin / ${energy_lowcut}-${energy_highcut} keV
la x TIME s (TSTART=$tstart or `<span style="text-decoration:line-through;color:blue;">suzaku_missiontime_to_utc.sh</span><span style="color:red;">hsSuzakuMissionTimeToUTC</span> $tstart`)
la y Count s\u-1\d
mark 17 on 1
mark 17 on 2
mark 17 on 3
EOF

if [ $show_sourcelc = &quot;true&quot; ];
then
echo &quot;col 1 on 1&quot; &gt;&gt; $tmppco
else
echo &quot;col off 1&quot; &gt;&gt; $tmppco
fi

if [ $show_bgdlc = &quot;true&quot; ];
then
echo &quot;col 2 on 2&quot; &gt;&gt; $tmppco
else
echo &quot;col off 2&quot; &gt;&gt; $tmppco
fi

if [ $show_allsubbgd = &quot;true&quot; ];
then
echo &quot;col 3 on 3&quot; &gt;&gt; $tmppco
else
echo &quot;col off 3&quot; &gt;&gt; $tmppco
fi

export PGPLOT_TYPE=&quot;/null&quot;
outputpsfile=`basename $outputpdffile .pdf`.ps
tmp2qdpprefix=`<span style="text-decoration:line-through;color:blue;">get_hash_random.pl</span><span style="color:red;">hsHashRandom</span>`
tmp2qdp=${tmp2qdpprefix}.qdp
tmp2pco=${tmp2qdpprefix}.pco
<span style="text-decoration:line-through;color:blue;">delete_qdp_files.sh</span><span style="color:red;">hsQDPDeleteQDPFiles</span> $tmp2qdpprefix
qdp $tmpqdp &lt;&lt; EOF &amp;&gt; /dev/null
ti of
we $tmp2qdpprefix
EOF

yminimum=`<span style="text-decoration:line-through;color:blue;">qdp_get_plot_range_from_a_pco_file.sh</span><span style="color:red;">hsQDPGetPlotRangeFromPCO</span> $tmp2pco y minimum`
ymaximum=`<span style="text-decoration:line-through;color:blue;">qdp_get_plot_range_from_a_pco_file.sh</span><span style="color:red;">hsQDPGetPlotRangeFromPCO</span> $tmp2pco y maximum`

<span style="text-decoration:line-through;color:blue;">delete_qdp_files.sh</span><span style="color:red;">hsQDPDeleteQDPFiles</span> $outputqdp
<span style="text-decoration:line-through;color:blue;">delete_qdp_files.sh</span><span style="color:red;">hsQDPDeleteQDPFiles</span> $outputpco
qdp $tmpqdp &lt;&lt; EOF &amp;&gt; /dev/null
ti of
r y 0 $ymaximum
pl
hard $outputdir/$outputpsfile/cps
we $outputqdpprefix
EOF

pushd $outputdir &amp;&gt; /dev/null
ps2pdf $outputpsfile
popd &amp;&gt; /dev/null

rm -f $source_tmp $bgd_tmp $source_bgd_tmp $tmppco $tmpqdp $tmp2pco $tmp2qdp
</pre>
</body>
</html>
