<html>
<body>
<pre>
#!/usr/bin/env perl

#20100124 perl path fixed

;#
;# a2ps: ascii to ps
;#
;# Copyright (c) 2001 Kazumasa Utashiro &lt;utashiro@srekcah.org&gt;
;# Copyright (c) 1990-1999 Kazumasa Utashiro
;# Internet Initiative Japan Inc.
;# 3-13 Kanda Nishiki-cho, Chiyoda-ku, Tokyo 101-0054, Japan
;#
;; $rcsid = q$Id: a2ps,v 1.45.1.1 2002/01/21 08:11:19 utashiro Exp $;
;#
;# This program is perl version of Miguel Santana&#39;s a2ps.  Postscript
;# kanji enhancement was done by Naoki Kanazawa &lt;kanazawa@sra.co.jp&gt;.
;# Converted to perl and enhanced by Kazumasa Utashiro.  B4 support
;# and punchmark was contributed by Masami Ueno
;# &lt;cabbage@kki.esi.yamanashi.ac.jp&gt;.
;#
;# Use and redistribution for ANY PURPOSE, with or without
;# modification, is granted as long as all copyright notices are
;# retained.  Although, it is strongly recommended to make it
;# obviously distinguishable from the original one when distributing
;# modified version.  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS
;# IS&#39;&#39; AND ANY EXPRESS OR IMPLIED WARRANTIES ARE DISCLAIMED.
;#
;# Note that this command will be renamed in the near future because
;# the original a2ps and perl version are upgraded in different ways.
;# Merging them together is preferable, though.
;#
;# Please change the next line to specify the default paper.
;# (&#39;us&#39; for US letter size, &#39;a4&#39; for A4 size, &#39;b4&#39; for B4 size)
;#
;;	$default_paper = &#39;a4&#39;;
;#
;# Change the next line to specify the default action of JIS code
;# conversion.  If you never use Japanese text or always using JIS coded
;# text, $jisconvert can be 0.  If the variable $jisconvert is true, a2ps
;# tries to convert the input text to jis code.  It tries to use some
;# converting program like nkf first.  If failed to exec these programs,
;# a2ps does conversion by itself.
;#
;;	$jisconvert = 1;
;#
;# WISH LIST
;#	- better algorithm to determine frame size (buggy on big font)
;#	- print toc matched pattern at the bottom of pages
;#	- half-line backward/forward have a effect inside of a line now
;#	- WTFM!
;#
@mon = (Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec);
@day = (Sun, Mon, Tue, Wed, Thu, Fri, Sat);
@mon{@mon} = ($[ .. $#mon);
@day{@day} = ($[ .. $#day);

@param_us = ( 8.50, 11.06, 0.65, 1.2, 6.85, 9.5, 0.29, 0.22, 0.12, &#39;letter&#39;);
@param_a4 = ( 8.27, 11.64, 1.20, 1.2, 6.60, 9.8, 0.29, 0.22, 0.05, &#39;a4&#39;);
@param_b4 = (10.15, 14.31, 1.40, 1.2, 8.50, 9.5, 0.29, 0.22, 0.08, &#39;b4&#39;);
sub paper {
    local(*param) = &#39;param_&#39; . $_[0];
    die &quot;Unknown paper type: $_[0]\n&quot; unless defined @param;
    ($width, $height, $lmargin, $smargin, $fontsize_l, $fontsize_p,
     $portrait_header, $landscape_header, $paper_adjust, $paper_tray) = @param;
}
&amp;paper($default_paper);

$pixels_inch = 72;
$selfconvert = 0;
$numbering = 0;
$folding = 1;
$restart = 1;
$visualize = 1;
$copies_number = 1;
$portrait = 0;
$wide_pages = 0;
$nuppage = 1;
$nup = 2;
$show_border = 1;
$show_header = 1;
$show_footer = 1;
$show_punchmark = 0;
$tab_w = 8;
$skip_column = 1;
$numformat = &#39;%-5d &#39;;
$oblique = 1;
$bold = 1;
$kanji_ascii_ratio = 1.0;
$default_sublabel = q#%month %mday %year %hour:%min#;

;# regexps for Japanese character code
$re_sjis_s = &#39;([\201-\237\340-\374][\100-\176\200-\374])+&#39;;
$re_euc_s  = &#39;([\241-\376]{2})+&#39;;
$re_jin    = &#39;\e\$[\@\B]&#39;;
$re_jout   = &#39;\e\([BJ]&#39;;

@font{&#39;n&#39;, &#39;b&#39;, &#39;u&#39;} = (&#39;C&#39;, &#39;B&#39;, &#39;O&#39;);		# normal, bold, underline
@font_number{&#39;C&#39;, &#39;B&#39;, &#39;O&#39;} = (0, 1, 2);	# Courier, Bold, Oblique

while ($_ = $ARGV[0], s/^-(.+)$/$1/ &amp;&amp; shift) {
    next if $_ eq &#39;&#39;;
    if (s/^help$//)		{&amp;usage;				next;}
    if (s/^basename$//)		{$basename++;				next;}
    if (s/^(us|a4|b4)$//i)	{&amp;paper($paper=&quot;\L$1&quot;);			next;}
    if (s/^l(.*)$//)		{defined($label=$1||shift)||&amp;usage;	next;}
    if (s/^L(.*)$//)		{defined($sublabel=$1||shift)||&amp;usage;	next;}
    if (s/^toc$//)		{defined($toc=shift)||&amp;usage;		next;}

    if (s/^k([\d\.]+)//)	{$kanji_ascii_ratio=$1;			redo;}
    if (s/^f([\d\.]+)//)	{$font_size=$1;				redo;}
    if (s/^fx([\d\.]+)//)	{$font_mag=$1;				redo;}
    if (s/^f([nbu])(.*)//)	{defined($font_number{$font{$1}=$2||shift}) ||
				 &amp;usage;				redo;}
    if (s/^j([\d\.]*)//)	{$ascii_mag=$1||1.2;			redo;}
    if (s/^d(\d*)//)		{$debug=$1||1;				redo;}

    if (s/^(n?)m//)		{$show_punchmark= !$1;			redo;}
    if (s/^(n?)h//)		{$show_header	= !$1;			redo;}
    if (s/^(n?)s//)		{$show_border	= !$1;			redo;}
    if (s/^(n?)t//)		{$show_footer	= !$1;			redo;}
    if (s/^(n?)C//)		{$selfconvert	= !$1;			redo;}
    if (s/^(n?)w//)		{$wide_pages	= !$1;			redo;}
    if (s/^(n?)c//)		{$jisconvert	= !$1;			redo;}
    if (s/^(n?)v//)		{$visualize	= !$1;			redo;}
    if (s/^(n?)p//)		{$portrait	= !$1;			redo;}
    if (s/^(n?)f//)		{$folding	= !$1;			redo;}
    if (s/^(n?)r//)		{$restart	= !$1;			redo;}
    if (s/^(n?)o//)		{$oblique	= !$1;			redo;}
    if (s/^(n?)b//)		{$bold		= !$1;			redo;}

    if (s/^(n?)n//)		{$numbering	= !$1;			redo;}
    if (s/^([12345])//)         {$nuppage=1; $nup=$1;                   redo;}
    &amp;usage;
}

sub usage {
    ($command = $0) =~ s#.*/##;
    select(STDERR); $|=0;
    print &quot;syntax: $command [switches] [files]\n&quot;;
    print &lt;&lt;&quot;    &gt;&gt;&quot;;
	switches are:
	-l \@	label string
	-L \@	sub-label string (\%default=&quot;$default_sublabel&quot;)
	-[n]t	tail label (t)
	-[n]n	numbering (nn)
	-[n]h	header (h)
	-[n]s	scale (s)
	-[n]m	punch mark (nm)
	-[n]w	wide page (nw)
	-[n]p	portrait (np)
	-[n]f	folding (f)
	-[n]c	convert to jis code (c)
	-[n]r	reset sheet number on each file (r)
	-[n]b	use bold/gothic font for overstruck characters (b)
	-[n]o	use oblique font for underlined characters (o)
	-[2345]  n-up column (2,3,4 or 5)
	-f[x]#	font size or maginificent (6.6 or 9.8)
	-fn#	normal font (C: Courier)
	-fb#	bold font (B: Courier-Bold)
	-fu#	underline font (O: Courier-BoldOblique)
	-k#	kanji:ascii font size ratio (1.0)
	-j[#]	adjust ascii font height to Japanese (1.0)
	-us/a4/b4
		US letter / A4 / B4
	-toc pattern
		specify table of contents pattern
	-help	print this message
    &gt;&gt;
    print &quot;($rcsid)\n&quot;;
    exit 1;
}

$nuppage = !($portrait || $wide_pages);
$font_size = $portrait ? $fontsize_p  : $fontsize_l unless $font_size;
$font_size *= $font_mag if ($font_mag);
$sheet_height = ($height - $lmargin) * $pixels_inch;
$sheet_width = ($width - $smargin) * $pixels_inch;
$char_width = 0.6 * $font_size;
$skip_column = 0 if ($numbering);
$esc = $visualize ? &#39;^[&#39; : &#39; &#39;;

($header, $page_width, $page_height) =
    $portrait ? ($portrait_header, $sheet_width, $sheet_height)
	      : ($landscape_header, $sheet_height, $sheet_width);
$header_size = $show_header ? $header * $pixels_inch : 0;
$linesperpage = (int(($page_height-$header_size)/($font_size * 1.1))) - 1;
if ($portrait || $wide_pages) {
    $columnsperline = (int($page_width / $char_width)) - 1;
} else {
    $page_height = ($height - ($lmargin * 5 / 3)) * $pixels_inch;
    $columnsperline = (int((int($page_height / $nup)) / $char_width)) - 1;
}

if ($linesperpage &lt;= 0 || $columnsperline &lt;= 0) {
    printf STDERR &quot;Font %g too big !!\n&quot;, $font_size;
    exit(1);
}

if ($debug == 2) {
    require(&#39;dumpvar.pl&#39;);
    local($#) = &#39;%.6g&#39;;
    &amp;dumpvar(&#39;main&#39;,
	     &#39;width&#39;, &#39;height&#39;, &#39;lmargin&#39;, &#39;smargin&#39;, &#39;font_size&#39;,
	     &#39;sheet_height&#39;, &#39;sheet_width&#39;, &#39;char_width&#39;, &#39;skip_column&#39;,
	     &#39;header&#39;, &#39;page_width&#39;, &#39;page_height&#39;, &#39;header_size&#39;,
	     &#39;linesperpage&#39;, &#39;columnsperline&#39;);
    exit(0);
}

$ordinal = 0;

push(@ARGV, &#39;&#39;) unless @ARGV;
while (@ARGV) {
    $file = shift;
    if ($file &amp;&amp; !-r $file) { warn &quot;$file: $!\n&quot;; next; }
    if ($jisconvert) {
	require &#39;flush.pl&#39;;
	&amp;flush(STDOUT);
	open(F, &quot;-|&quot;) || &amp;jis($file);
    } else {
	$file = &#39;-&#39; if $file eq &#39;&#39;;
	open(F, $file) || do { print STDERR &quot;$file: $!\n&quot;; next; };
    }
    $file = &#39;stdin&#39; if $file =~ /^-?$/;
    if ($toc) {
	$TOC = $file . &#39;.toc&#39;;
	die &quot;$TOC exists.\n&quot; if -e $TOC;
	open(TOC, &quot;&gt;$TOC&quot;) || die &quot;$TOC: $!\n&quot;;
    }
    &amp;print_file($file, $label);
    close F;
    close TOC if $toc;
}

if ($header_is_printed) {
    print &quot;\n&quot;;
    print &quot;cleanup\n&quot;;
    print &quot;%%Trailer\n&quot;;
    print &quot;docsave restore end\n&quot;;
}

exit;

############################################################

sub print_file {
    local($name, $label) = @_;
    defined($label) || ($label = $name || &#39;stdin&#39;);
    $label =~ s:.*/:: if $basename;
    $label =~ s/([\(\)\\])/\\$1/g;
    defined($sublabel) &amp;&amp; do { $sublabel =~ s/([\(\)\\])/\\$1/g; };
    $line_number = 0;

    &amp;print_header;

    if ($restart) {
	$sheets = 0;
    }
    $page = 0;
    $maxrest = $columnsperline - $skip_column;
    $numberwidth = length(sprintf($numformat,0));
    $maxrest -= $numberwidth if $numbering;
    $lastnumber = -1;
    $show = &#39;s&#39;;
    $line = 1; $bl = 1;

    while (&lt;F&gt;) {
	$line_number++;
	if ($toc &amp;&amp; /$toc/o) {
	    print TOC &quot;$sheets:$page:$line_number:$+:$_&quot;;
	}
	if (/\t/) {
	    $_ = &amp;expand($_, $tab_w);
	}
	if ($visualize) {
	    s/([\200-\377])/&#39;M-&#39;.pack(&#39;c&#39;,ord($1)&amp;0177)/ge;
	    s/([\000-\007\013\016-\032\034-\037])/&#39;^&#39;.pack(&#39;c&#39;,ord($1)|0100)/ge;
	    s/\0177/^?/g;
	} else {
	    s/[\000-\032\034-\037\177-\377]/ /g;
	}

	# enclose Japanese text by \05 and \06
	s/\e\$[B\@]/\005/g;
	s/\e\([BJ]/\006/g;

	# enclose overstruck segment by \01 and \02
	if (/\cH/ &amp;&amp; $bold) {
	    s/(..)\06?\cH\cH\05?\1/\01$1\02/g;
	    s/(.)(\cH\1)+/\01$1\02/g;
	    s/\02\01//g;
	}
	# enclose underlined segment by \03 and \04
	if (/\cH/ &amp;&amp; $oblique) {
	    s/__\cH\cH(\05)?(..)/\03$1$2\04/g;
	    s/_\cH(.)/\03$1\04/g;
	    s/\04\03//g;
	}

	$kanji = 0;
	$rest = $maxrest;
	@l = split(/([\001-\006\b\f\n\r\e])/);
	while (defined($w = shift(@l))) {
	    if ($w eq &#39;&#39;)   { next; }
	    if ($w eq &quot;\f&quot;) { $bl || &amp;nl; &amp;rp; next; }	# formfeed
	    $bl &amp;&amp; &amp;bl;
	    if ($w eq &quot;\b&quot;) { $rest++, print &#39; bs&#39; if $rest &lt; $maxrest; next; }
	    if ($w eq &quot;\n&quot;) { &amp;nl; next; }		# newline
	    if ($w eq &quot;\r&quot;) { &amp;cr; &amp;bl; next; }		# carriage return
	    if ($w eq &quot;\1&quot;) { print &#39; B&#39;; next; }	# bold start
	    if ($w eq &quot;\2&quot;) { print &#39; R&#39;; next; }	# bold end
	    if ($w eq &quot;\3&quot;) { print &#39; I&#39;; next; }	# italic start
	    if ($w eq &quot;\4&quot;) { print &#39; R&#39;; next; }	# italic end
	    if ($w eq &quot;\5&quot;) { $kanji = 1; next; }	# kanji start
	    if ($w eq &quot;\6&quot;) { $kanji = 0; next; }	# kanji end
            if ($w eq &quot;\e&quot;) {				# half line/char moves
		if ($l[$[] =~ s/^6//) { &amp;half_char_back; next; }
		if ($l[$[] =~ s/^7//) { &amp;half_char_forw; next; }
		if ($l[$[] =~ s/^8//) { &amp;half_line_back; next; }
		if ($l[$[] =~ s/^9//) { &amp;half_line_forw; next; }
		$w = $esc;
	    }
	    if ($folding) {
		$show_width = $rest &amp; ~$kanji;
		if ($show_width &lt; length($w)) {
		    ($w, $folded) = unpack(&quot;a$show_width a*&quot;, $w);
		}
	    }
	    $rest -= length($w);
	    $w =~ s/([\(\)\\])/\\$1/g;
	    print &#39; kanji_init&#39; if $kanji &amp;&amp; !$kanji_init++;
	    print &#39; (&#39;, $w, &#39;) &#39;, $kanji ? &#39;ks&#39; : &#39;s&#39;;
	    if (defined $folded) {
		$w = $folded; undef $folded; &amp;nl;
		redo;
	    }
	}
    }
    &amp;ep;
}

sub rp {
    if ($line % $linesperpage != 1) {
	$line = $linesperpage * (int($line/$linesperpage) + 1) + 1;
    }
}

sub np {
    &amp;ep if $page++ &gt; 0;
    if (!$nuppage || $nup==1 || ($page % $nup) == 1) {
	$sheets++;
	if ($ordinal++) {
	    print &quot;cleanup\n&quot;;
	}
	print &quot;%%Page: $sheets $ordinal\n&quot;;
	print &quot;/sheet $sheets def\n&quot;;
	print &quot;($label) setlabel\n&quot;;
	$kanji_init = 0;
	print &quot;kanji_init\n&quot; if $kanji;
    }
    print &quot;$page startpage\n&quot;;
    &amp;rp;
}

sub bl {
    &amp;np if $bl &amp;&amp; ($line % $linesperpage) == 1;
    $bl = 0;
    $rest = $maxrest;
    print &#39;bl (&#39;, &#39; &#39; x $skip_column;
    if ($numbering) {
	if ($line_number != $lastnumber) {
	    printf ($numformat, $line_number);
	    $lastnumber = $line_number;
	} else {
	    print &#39; &#39; x $numberwidth;
	}
    }
    print &#39;) s&#39;;
}

sub nl { $line++; print &quot; nl\n&quot;; $bl = 1; }
sub cr { print &#39; cr &#39;; }

sub half_line_back { print &#39; hlr&#39;; }
sub half_line_forw { print &#39; hlf&#39;; }
sub half_char_back { print &#39; hcr&#39;; }
sub half_char_forw { print &#39; hcf&#39;; }

sub ep {
    print &quot;\nendpage\n&quot;;
}

sub max { $_[ ($_[$[] &lt; $_[$[+1]) + $[]; }

sub expand {
    local($_, $tw) = @_;
    $tw = 8 unless $tw;
    1 while s/^([^\t]*)(\t+)/$1.&#39; &#39;x(length($2)*$tw-&amp;pwidth($1)%$tw)/e;
    $_;
}

sub pwidth {
    local($_) = shift;
    if (/[\e\b\f\r]/) {
	s/^.*[\f\r]//;
	s/\e\$[\@B]|\e\([JB]//g;
	s/\e[89]//g;
	s/\e6.\e6//g;
	1 while s/[^\cH]\cH//;
	s/^\cH+//;
    }
    length;
}

sub jis {
    unless ($selfconvert) {
	shift while @_ &gt; 0 &amp;&amp; $_[0] eq &#39;&#39;;
	exec(&#39;nkf&#39;, &#39;-b&#39;, &#39;-j&#39;, @_);
	exec(&#39;jconv&#39;, &#39;-j&#39;, @_);
    }
    if (($file = shift) ne &#39;&#39;) {
	open(STDIN, $file) || die &quot;$file: $!\n&quot;;
    }

    local($jcode, @readahead, $convf);

    while (&lt;STDIN&gt;) {
	print, next if !@readahead &amp;&amp; !/[\033\200-\377]/;
	push(@readahead, $_);
	next unless $jcode = &amp;jcode(*_);
	$convf = ($jcode || &#39;jis&#39;) . &#39;2jis&#39;;
	eval &quot;do \$convf(*_), print while \$_ = shift(\@readahead);&quot; .
	     &quot;do \$convf(*_), print while &lt;STDIN&gt;;&quot;;
	exit(0);
    }
    print @readahead;
    exit(0);
}

sub jcode {
    local(*_, $sjis, $euc) = @_;
    return undef unless /[\033\200-\377]/;
    return &#39;jis&#39; if /$re_jin|$re_jout/o;
    $sjis += length($1) while /($re_sjis_s)/go;
    $euc += length($1) while /($re_euc_s)/go;
    return (&#39;euc&#39;, undef, &#39;sjis&#39;)[($sjis &lt;=&gt; $euc) + $[ + 1];
}

sub jis2jis { 1; }

sub sjis2jis {
    local(*_) = @_;
    s/($re_sjis_s)/&amp;_sjis2jis($1)/geo;
}
sub _sjis2jis {
    local($_) = @_;
    s/(..)/$s2j{$1}||&amp;s2j($1)/ge;
    &quot;\e\$B&quot; . $_ . &quot;\e\(B&quot;;
}
sub s2j {
    local($c1, $c2, $code);
    ($c1, $c2) = unpack(&#39;CC&#39;, $code = shift);

    if ($c2 &gt;= 0x9f) {
	$c1 = ($c1 * 2 - ($c1 &gt;= 0xe0 ? 0xe0 : 0x60)) &amp; 0x7f;
	$c2 -= 0x7e;
    } else {
	$c1 = ($c1 * 2 - ($c1 &gt;= 0xe0 ? 0xe1 : 0x61)) &amp; 0x7f;
	$c2 = ($c2 + 0x60 + ($c2 &lt; 0x7f)) &amp; 0x7f;
    }
    $s2j{$code} = pack(&#39;CC&#39;, $c1, $c2);
}

sub euc2jis {
    local(*_) = @_;
    s/($re_euc_s)/&amp;_euc2jis($1)/geo;
}
sub _euc2jis {
    local($_) = @_;
    tr/\200-\377/\000-\177/;
    &quot;\e\$B&quot; . $_ . &quot;\e\(B&quot;;
}

sub print_header {
    require(&#39;ctime.pl&#39;);
    return if $header_is_printed++;

    chop(local($date) = &amp;ctime(time));
    local($orientation) = $portrait ? &quot;Portrait&quot; : &quot;Landscape&quot;;

    print &lt;&lt;&quot;---&quot;;
\%!PS-Adobe-1.0
\%\%Title: $label
\%\%Creator: $rcsid
\%\%CreationDate: $date
\%\%Pages: (atend)
\%\%PageOrder: Ascend
\%\%DocumentPaperSizes: \U$paper_tray\E
\%\%Orientation: $orientation
\%\%EndComments

/\$a2psdict 100 dict def
\$a2psdict begin
\% Initialize page description variables.
/inch {72 mul} bind def
---
    print &quot;%% SelectTray\n&quot;;
    print &quot;statusdict /${paper_tray}tray known { &quot;;
    print &quot;statusdict begin ${paper_tray}tray end } if\n&quot;;

    printf(&quot;/landscape %s def\n&quot;, !$portrait ? &quot;true&quot; : &quot;false&quot;);
    printf(&quot;/nuppage %s def\n&quot;, $nuppage ? &quot;true&quot; : &quot;false&quot;);
    printf(&quot;/nup %d def\n&quot;, $nup);
    printf(&quot;/sheetheight %g inch def\n&quot;, $height);
    printf(&quot;/sheetwidth %g inch def\n&quot;, $width);
    printf(&quot;/lmargin %g inch def\n&quot;, $lmargin);
    printf(&quot;/smargin %g inch def\n&quot;, $smargin);
    printf(&quot;/paper_adjust %g inch def\n&quot;, $paper_adjust);
    printf(&quot;/noborder %s def\n&quot;, $show_border ? &quot;false&quot; : &quot;true&quot;);
    if ($show_header) {
	printf(&quot;/noheader false def\n&quot;);
	printf(&quot;/headersize %g inch def\n&quot;,
	       $portrait ? $portrait_header : $landscape_header);
    } else {
	print &quot;/noheader true def\n&quot;;
	print &quot;/headersize 0.0 def\n&quot;;
    }
    print &quot;/nofooter &quot;, $show_footer ? &quot;false&quot; : &quot;true&quot;, &quot; def\n&quot;;
    print &quot;/nopunchmark &quot;, $show_punchmark ? &quot;false&quot; : &quot;true&quot;, &quot; def\n&quot;;
    printf(&quot;/bodyfontsize %g def\n&quot;, $font_size);
    printf(&quot;/kanjiAsciiRatio %g def\n&quot;, $kanji_ascii_ratio);
    printf(&quot;/lines %d def\n&quot;, $linesperpage);
    printf(&quot;/columns %d def\n&quot;, $columnsperline);
    $sublabel = $default_sublabel unless defined $sublabel;
    print &quot;/date (&quot;, &amp;date($sublabel, time), &quot;) def\n&quot;;
    if ($ascii_mag) {
	printf(&quot;/doasciimag true def /asciimagsize %f def\n&quot;, $ascii_mag);
    } else {
	printf(&quot;/doasciimag false def\n&quot;);
    }
    &amp;print_template;

    if ($copies_number &gt; 1) {
	printf(&quot;/#copies %d def\n&quot;, $copies_number);
    }

    printf &quot;/R { /fonttype %s def } bind def\n&quot;, $font_number{$font{&#39;n&#39;}};
    printf &quot;/B { /fonttype %s def } bind def\n&quot;, $font_number{$font{&#39;b&#39;}};
    printf &quot;/I { /fonttype %s def } bind def\n&quot;, $font_number{$font{&#39;u&#39;}};
    print &quot;R\n&quot;;

    printf(&quot;/docsave save def\n&quot;);
    printf(&quot;startdoc\n&quot;);

    print &quot;%%EndProlog\n\n&quot;;
}

sub date {
    local($_, $time) = @_;
    local($sec, $min, $hour, $mday, $mon, $year, $wday) = localtime($time);
    $year += 1900;

    s/[\\%]%/\377/g;				# save escaped %
    s/%default/$default_sublabel/g;		# %default

    s/%user/$ENV{&#39;USER&#39;}||(getpwuid($&lt;))[0]/ge;	# %user

    # compatible with mh_format(5)
    s/%month\b/$mon[$mon]/g;			# %month
    s/%sec\b/sprintf(&quot;%02d&quot;,$sec)/ge;		# %sec
    s/%min\b/sprintf(&quot;%02d&quot;,$min)/ge;		# %min
    s/%hour\b/$hour/g;				# %hour
    s/%mday\b/$mday/g;				# %mday
    s/%mon\b/$mon+1/ge;				# %mon
    s/%wday\b/$wday/g;				# %wday
    s/%year\b/$year/g;				# %year
    s/%day\b/$day[$wday]/g;			# %day

    s/\377/%/g;					# restore %
    $_;
}

sub print_template {
    return if $debug;

    print &lt;&lt;&#39;__TEMPLATE__&#39;;
%!  PostScript Source Code
%
%  File: imag:/users/local/a2ps/header.ps
%  Created: Tue Nov 29 12:14:02 1988 by miguel@imag (Miguel Santana)
%  Version: 2.0
%  Description: PostScript prolog for a2ps ascii to PostScript program.
% 
%  Edit History:
%  - Original version by evan@csli (Evan Kirshenbaum).
%  - Modified by miguel@imag to:
%    1) Correct an overflow bug when printing page number 10 (operator
%	cvs).
%    2) Define two other variables (sheetwidth, sheetheight) describing
%	the physical page (by default A4 format).
%    3) Minor changes (reorganization, comments, etc).
%  - Modified by tullemans@apolloway.prl.philips.nl
%    1) Correct stack overflows with regard to operators cvs and copy.
%       The resulting substrings where in some cases not popped off 
%       the stack, what can result in a stack overflow.
%    2) Replaced copypage and erasepage by showpage. Page througput
%       degrades severely (see red book page 140) on our ps-printer
%       after printing sheet 16 (i.e. page 8) of a file which was 
%       actually bigger. For this purpose the definitions of startdoc
%       and startpage are changed.
%  - Modified by Tim Clark &lt;T.Clark@uk.ac.warwick&gt; to:
%    1) Print one page per sheet (portrait) as an option.
%    2) Reduce size of file name heading, if it&#39;s too big.
%    3) Save and restore PostScript state at begining/end. It now uses
%	conventional %%Page %%Trailer markers.
%    4) Print one wide page per sheet in landscape mode as an option.
%  - Modified by miguel@imag.fr to
%    1) Add new option to print n copies of a file.
%    2) Add new option to suppress heading printing.
%    3) Add new option to suppress page surrounding border printing.
%    4) Add new option to change font size. Number of lines and columns
%	are now automatically adjusted, depending on font size and
%	printing mode used.
%    5) Minor changes (best layout, usage message, etc).
%  - Modified by kanazawa@sra.co.jp to:
%    1) Handle Japanese code
%  - Modified by utashiro@sra.co.jp to:
%    1) Fix bug in printing long label
%    2) Handle carriage-return
%    3) Specify kanji-ascii character retio
%    4) Add footer label
%    5) Change filename-&gt;fname becuase ghostscript has operator filename
%    6) Support three different font style
%    7) Incorporate B4 paper support and punchmark contributed
%       by Masami Ueno &lt;cabbage@kki.esi.yamanashi.ac.jp&gt;
%

% Copyright (c) 1988, Miguel Santana, miguel@imag.imag.fr
%
% Permission is granted to copy and distribute this file in modified
% or unmodified form, for noncommercial use, provided (a) this copyright
% notice is preserved, (b) no attempt is made to restrict redistribution
% of this file, and (c) this file is not distributed as part of any
% collection whose redistribution is restricted by a compilation copyright.
%


% General macros.
/xdef {exch def} bind def
/getfont {exch findfont exch scalefont} bind def

% Page description variables and inch function are defined by a2ps program.

% Character size for differents fonts.
   landscape
   { /filenamefontsize 10 def }
   { /filenamefontsize 16 def }
ifelse
/datefontsize filenamefontsize 0.8 mul def
/headermargin filenamefontsize 0.25 mul def
/bodymargin bodyfontsize 0.7 mul def

% Font assignment to differents kinds of &quot;objects&quot;
/filenamefontname /Helvetica-Bold def
/stdfilenamefont filenamefontname filenamefontsize getfont def
/datefont /Helvetica datefontsize getfont def
/footerfont /Helvetica-Bold datefontsize getfont def
/mag { doasciimag { [ 1 0 0 asciimagsize 0 0 ] makefont } if } def
/bodynfont /Courier bodyfontsize getfont mag def
/bodybfont /Courier-Bold bodyfontsize getfont mag def
/bodyofont /Courier-BoldOblique bodyfontsize getfont mag def
/fontarray [ bodynfont bodybfont bodyofont ] def
/bodyfont bodynfont def

% Initializing kanji fonts
/kanji_initialized false def
/kanji_init {
   kanji_initialized not
   {
      /bodykfontsize bodyfontsize kanjiAsciiRatio mul def
      /bodyknfont /Ryumin-Light-H bodykfontsize getfont def
      /bodykbfont /GothicBBB-Medium-H bodykfontsize getfont def
      /bodykofont bodykbfont [ 1 0 .2 1 0 0 ] makefont def
      /KanjiRomanDiff 1.2 bodyfontsize mul 1.0 bodykfontsize mul sub def
      /KanjiRomanDiffHalf KanjiRomanDiff 2 div def
      /kfontarray [ bodyknfont bodykbfont bodykofont ] def
      /kanji_initialized true def
   } if
} def

% Backspace width
/backspacewidth
   bodyfont setfont (0) stringwidth pop
   def

% Logical page attributs (a half of a real page or sheet).
/pagewidth
   bodyfont setfont (0) stringwidth pop columns mul bodymargin dup add add
   def
/pageheight
   bodyfontsize 1.1 mul lines mul bodymargin dup add add headersize add
   def

% Coordinates for upper corner of a logical page and for sheet number.
% Coordinates depend on format mode used.
% In nuppage mode, coordinate x of upper corner is not the same for left
% and right pages: upperx is an array of two elements, indexed by sheetside.
/rightmargin smargin 3 div def
/leftmargin smargin 2 mul 3 div def
/topmargin lmargin nuppage {3} {2} ifelse div def
landscape
{  % Landscape format
   /punchx .4 inch def           % for PunchMark
   /punchy sheetwidth 2 div def  % for PunchMark
   /uppery rightmargin pageheight add bodymargin add def
   /sheetnumbery sheetwidth leftmargin pageheight add datefontsize add sub def
   nuppage
   {  % N-up logical pages
      /upperx [ topmargin 2 mul			% upperx for left page
         nup 2 eq {
	    % upperx for right page
	    dup topmargin add pagewidth add
	} if
	nup 3 eq {
	    % upperx for middle and right pages
	    dup topmargin 2 div add pagewidth add
	    dup topmargin 2 div add pagewidth add
	} if
	nup 4 eq {
	    % upperx for middle (left, right) and right pages
	    dup topmargin 2 div add pagewidth add
	    dup topmargin 2 div add pagewidth add
	    dup topmargin 2 div add pagewidth add
	} if
	nup 5 eq {
	    % upperx for middle (left, right) and right pages
	    dup topmargin 2 div add pagewidth add
	    dup topmargin 2 div add pagewidth add
	    dup topmargin 2 div add pagewidth add
	    dup topmargin 2 div add pagewidth add
	} if
      ] def
      nup 1 eq {		  
         /sheetnumberx sheetheight def
      } if
      nup 2 eq {
         /sheetnumberx sheetheight topmargin 2 mul sub def
      } if
      nup 3 eq {		  
         /sheetnumberx sheetheight topmargin 1.75 mul sub def
      } if
      nup 4 eq {		  
         /sheetnumberx sheetheight topmargin 1.25 mul sub def
      } if
      nup 5 eq {		  
         /sheetnumberx sheetheight topmargin sub def
      } if
   }
   {  /upperx [ topmargin dup ] def
      /sheetnumberx sheetheight topmargin sub datefontsize sub def
   }
   ifelse
}
{  % Portrait format
   /punchx .3 inch def
   /punchy sheetheight 2 div def
   /uppery topmargin pageheight add def
   /upperx [ leftmargin dup ] def
   /sheetnumberx sheetwidth rightmargin sub datefontsize sub def
   /sheetnumbery
	 sheetheight 
	 topmargin pageheight add datefontsize add headermargin add
      sub
      def
}
ifelse

% Strings used to make easy printing numbers
/pnum 12 string def
/empty 12 string def

% Other initializations.
datefont setfont
/datewidth date stringwidth pop def
/pagenumwidth (Page 999) stringwidth pop def
/filenameroom
         pagewidth
	 filenamefontsize 4 mul datewidth add pagenumwidth add
      sub
   def


% Function startdoc: initializes printer and global variables.
/startdoc
    { /sheetside 0 def			% sheet side that contains current page
   } bind def

% Function setlabel: initialize label in header
/setlabel
    { stdfilenamefont setfont
      /fname xdef
      /filenamewidth fname stringwidth pop def
      /filenamefont
	 filenamewidth filenameroom gt
	 {
	       filenamefontname
	       filenamefontsize filenameroom mul filenamewidth div
	    getfont
	 }
	 {  stdfilenamefont }
	 ifelse
	 def
    } bind def

% Function printpage: Print a physical page.
/printpage
    { /sheetside 0 def
      nuppage
      {  sheetnumber }
      {  noheader noborder not and
	    { sheetnumber }
	 if
      }
      ifelse
      showpage 
%      pagesave restore
%      /sheet sheet 1 add def
    } bind def

% Function cleanup: terminates printing, flushing last page if necessary.
/cleanup
    { nuppage sheetside 0 gt and
         { printpage }
      if
    } bind def

%
% Function startpage: prints page header and page border and initializes
% printing of the file lines.  Page number is stored on the top of stack,
% and file name is next.
/startpage
    { /pagenum exch def
      sheetside 0 eq
	{ % /pagesave save def
	  landscape
	    { sheetwidth 0 inch translate	% new coordinates system origin
	      90 rotate				% landscape format
	      paper_adjust neg 0 translate
	    } if
	} if
      noborder not { printborder } if
      noheader not { printheader } if
      nofooter not { printfooter } if
      nopunchmark not { punchmark } if
	 upperx sheetside get  bodymargin  add
	    uppery
	    bodymargin bodyfontsize add  noheader {0} {headersize} ifelse  add
	 sub
      moveto
    } bind def

% Function printheader: prints page header.
/printheader
    { upperx sheetside get  uppery headersize sub 1 add  moveto
      datefont setfont
      gsave
        datefontsize headermargin rmoveto
	date show					% date/hour
      grestore
      gsave
	pagenum pnum cvs pop
	   pagewidth pagenumwidth sub
	   headermargin
	rmoveto
        (Page ) show pnum show				% page number
      grestore
      empty pnum copy pop
      gsave
        filenamefont setfont
	      filenameroom fname stringwidth pop sub 2 div datewidth add
	      filenamefontsize 2 mul 
	   add 
	   headermargin
	rmoveto
        fname show						% file name
      grestore
    } bind def

% Function printfooter: prints page footer.
/printfooter
    { upperx 0 get sheetnumbery moveto
      footerfont setfont
      fname show
    } bind def

% Function printborder: prints border page.
/printborder 
    { upperx sheetside get uppery moveto
      gsave					% print the four sides
        pagewidth 0 rlineto			% of the square
        0 pageheight neg rlineto
        pagewidth neg 0 rlineto
        closepath stroke
      grestore
      noheader not
         { 0 headersize neg rmoveto pagewidth 0 rlineto stroke }
      if
    } bind def

% Punch Marker
/punchmark {
  gsave
    newpath punchx punchy moveto
    punchx 2 add punchy -0.5 add lineto
    punchx 2 add punchy 0.5 add lineto
    punchx punchy lineto
    closepath
    0 setgray .8 setlinewidth stroke
  grestore
  } bind def

%
% Function endpage: adds a sheet number to the page (footnote) and prints
% the formatted page (physical impression). Activated at the end of each
% source page (lines reached or FF character).
/endpage
   { nuppage  sheetside nup 1 sub lt  and
        { /sheetside sheetside 1 add def }
        { printpage }
     ifelse
   } bind def

% Function sheetnumber: prints the sheet number.
/sheetnumber
    { sheetnumberx sheetnumbery moveto
      datefont setfont
      sheet pnum cvs
	 dup stringwidth pop (0) stringwidth pop sub neg 0 rmoveto show
      empty pnum copy pop
    } bind def

% Function bs: go back one character width to emulate BS
/bs { backspacewidth neg 0 rmoveto } bind def

% Function s: print a source string
/s  { fontarray fonttype get setfont
      show
    } bind def

% Function ks: print a kanji source string
/ks { kfontarray fonttype get setfont
      KanjiRomanDiffHalf 0 rmoveto
      KanjiRomanDiff 0 3 -1 roll ashow
      KanjiRomanDiffHalf neg 0 rmoveto
    } def

% Function bl: beginning of line
/bl { gsave } bind def

% Function nl: newline
/nl {
      grestore
      0 bodyfontsize 1.1 mul neg rmoveto
    } bind def

% Function cr: carriage return
/cr { grestore } bind def

% Function hlr: half-line up
/hlr { 0 bodyfontsize 0.55 mul rmoveto } bind def

% Function hlr: half-line down
/hlf { 0 bodyfontsize 0.55 mul neg rmoveto } bind def

% Function hlr: half-character backward
/hcr { backspacewidth 2 div neg 0 rmoveto } bind def

% Function hlr: half-character forward
/hcf { backspacewidth 2 div 0 rmoveto } bind def

__TEMPLATE__
}
</pre>
</body>
</html>
